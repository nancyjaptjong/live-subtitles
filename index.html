<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Dutch → Papiamentu Subtitles</title>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .topbar {
      position: fixed; top: 0; left: 0; right: 0;
      padding: 12px 16px;
      background: #111; color: #fff;
      display: flex; gap: 10px; align-items: center;
      z-index: 10000;
    }
    button { padding: 10px 14px; font-size: 16px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { margin-left: auto; opacity: 0.9; }
    .page {
      padding-top: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 64px);
      text-align: center;
      color: #333;
    }
    #subtitleBar {
      position: fixed; left: 0; right: 0; bottom: 0;
      padding: 18px 24px;
      font-size: 32px;
      line-height: 1.2;
      background: rgba(0,0,0,0.75);
      color: #fff;
      text-align: center;
      z-index: 9999;
      user-select: none;
      min-height: 56px;
    }
    /* Presentation mode */
    body.presentation .topbar { display: none; }
    body.presentation .page { padding-top: 0; min-height: 100vh; }
  </style>
</head>

<body>
  <div class="topbar">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <span class="status" id="status">Idle</span>
  </div>

  <div class="page">
    <div>
      <h1 style="margin: 0 0 8px;">Live Dutch → Papiamentu Subtitles</h1>
      <p style="margin: 0; opacity: 0.8;">
        Click <b>Start</b>, allow microphone, then speak Dutch.
      </p>
      <p style="margin: 12px 0 0; opacity: 0.7; font-size: 14px;">
        Presentation mode: add <code>?presentation=true</code> to the URL.
      </p>
    </div>
  </div>

  <div id="subtitleBar"></div>

  <script>
    // ===== Config =====
    const TOKEN_ENDPOINT = "/token";
    const SOURCE_LANGUAGE = "nl"; // Dutch

    // Presentation mode
    const params = new URLSearchParams(location.search);
    if (params.get("presentation") === "true") document.body.classList.add("presentation");

    // ===== UI =====
    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const statusEl = document.getElementById("status");
    const subtitleBar = document.getElementById("subtitleBar");

    function setStatus(msg) { statusEl.textContent = msg; }
    function setSubtitle(text) { subtitleBar.textContent = text || ""; }
    function safeJsonParse(s) { try { return JSON.parse(s); } catch { return null; } }

    // ===== State =====
    let pc = null;
    let dc = null;
    let localStream = null;

    async function getEphemeralKey() {
      const resp = await fetch(TOKEN_ENDPOINT, { cache: "no-store" });
      if (!resp.ok) throw new Error(`Token endpoint error: ${resp.status} ${await resp.text()}`);
      const data = await resp.json();
      const key = data.value ?? data.client_secret?.value;
      if (!key) throw new Error("No ephemeral key returned from /token");
      return key;
    }

    async function start() {
      try {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        setStatus("Requesting mic…");
        setSubtitle("");

        const EPHEMERAL_KEY = await getEphemeralKey();

        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        setStatus("Connecting…");

        pc = new RTCPeerConnection();
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        dc = pc.createDataChannel("oai-events");

        dc.onopen = () => {
          setStatus("Live");

          const instructions =
            "You are a live subtitle translator. The speaker talks in Dutch. " +
            "Output ONLY the translated subtitle in Papiamentu. " +
            "No explanations. Keep it short and readable.";

          // Configure the session
          dc.send(JSON.stringify({
            type: "session.update",
            session: {
              instructions,
              input_audio_transcription: { model: "gpt-4o-mini-transcribe", language: SOURCE_LANGUAGE },
              modalities: ["text"]
            }
          }));

          // Start generating text
          dc.send(JSON.stringify({
            type: "response.create",
            response: {
              modalities: ["text"],
              instructions: "Begin translating now. Output only Papiamentu subtitles."
            }
          }));
        };

        dc.onmessage = (event) => {
          const msg = safeJsonParse(event.data);
          if (!msg) return;

          // Streaming delta text
          if (msg.type === "response.output_text.delta" && typeof msg.delta === "string") {
            setSubtitle((subtitleBar.textContent || "") + msg.delta);
            return;
          }

          // Final text
          if (msg.type === "response.output_text.done") {
            if (typeof msg.text === "string" && msg.text.trim()) setSubtitle(msg.text.trim());
            return;
          }

          // Completed response (alt shape)
          if (msg.type === "response.completed") {
            const text =
              msg?.response?.output?.[0]?.content?.find?.(c => c.type === "output_text")?.text ||
              msg?.response?.output_text ||
              null;
            if (typeof text === "string" && text.trim()) setSubtitle(text.trim());
          }
        };

        // SDP exchange
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = "https://api.openai.com/v1/realtime";
        const model = "gpt-realtime";

        const sdpResp = await fetch(`${baseUrl}?model=${encodeURIComponent(model)}`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${EPHEMERAL_KEY}`,
            "Content-Type": "application/sdp"
          },
          body: offer.sdp
        });

        if (!sdpResp.ok) throw new Error(`Realtime SDP exchange failed: ${sdpResp.status} ${await sdpResp.text()}`);

        const answerSdp = await sdpResp.text();
        await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

        setStatus("Live");
      } catch (err) {
  console.error(err);
  setStatus("ERROR: " + (err?.message || String(err)));
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

      }
    }

    async function stop() {
      try {
        setStatus("Stopping…");
        stopBtn.disabled = true;

        if (dc) { try { dc.close(); } catch {} dc = null; }
        if (pc) { try { pc.close(); } catch {} pc = null; }

        if (localStream) {
          localStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
          localStream = null;
        }

        setSubtitle("");
        setStatus("Idle");
      } finally {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    startBtn.addEventListener("click", start);
    stopBtn.addEventListener("click", stop);
  </script>
</body>
</html>

