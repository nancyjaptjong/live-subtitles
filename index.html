<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Dutch → Papiamentu Subtitles</title>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .topbar{
      position:fixed; top:0; left:0; right:0;
      padding:12px 16px;
      background:#111; color:#fff;
      display:flex; gap:10px; align-items:center;
      z-index:10000;
    }
    button{ padding:10px 14px; font-size:16px; cursor:pointer; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .status{ margin-left:auto; opacity:.95; }
    .page{
      padding-top:64px;
      min-height:calc(100vh - 64px);
      display:flex; align-items:center; justify-content:center;
      text-align:center; color:#333;
    }
    #subtitleBar{
      position:fixed; left:0; right:0; bottom:0;
      padding:18px 24px;
      font-size:32px; line-height:1.2;
      background:rgba(0,0,0,.75);
      color:#fff; text-align:center;
      z-index:9999;
      user-select:none;
      min-height:56px;
      white-space:pre-wrap;
    }
    body.presentation .topbar { display:none; }
    body.presentation .page { padding-top:0; min-height:100vh; }
  </style>
</head>

<body>
  <div class="topbar">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <span class="status" id="status">Idle</span>
  </div>

  <div class="page">
    <div>
      <h1 style="margin:0 0 8px;">Live Dutch → Papiamentu Subtitles</h1>
      <p style="margin:0; opacity:.8;">
        Click <b>Start</b>, allow microphone, then speak Dutch.
      </p>
      <p style="margin:12px 0 0; opacity:.7; font-size:14px;">
        Presentation mode: add <code>?presentation=true</code> to the URL.
      </p>
    </div>
  </div>

  <div id="subtitleBar"></div>

  <script>
    // ========================
    // CONFIG
    // ========================
    const TOKEN_ENDPOINT = "/token";   // Cloudflare Pages Function
    const SOURCE_LANGUAGE = "nl";      // Dutch

    // Presentation mode
    const params = new URLSearchParams(location.search);
    if (params.get("presentation") === "true") document.body.classList.add("presentation");

    // ========================
    // UI
    // ========================
    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const statusEl = document.getElementById("status");
    const subtitleBar = document.getElementById("subtitleBar");

    function setStatus(msg){ statusEl.textContent = msg; }
    function setSubtitle(text){ subtitleBar.textContent = text || ""; }

    // ========================
    // STATE
    // ========================
    let pc = null;
    let dc = null;
    let localStream = null;

    // ========================
    // HELPERS
    // ========================
    function safeJsonParse(s){ try { return JSON.parse(s); } catch { return null; } }

    async function getEphemeralKey(){
      const resp = await fetch(TOKEN_ENDPOINT, { cache: "no-store" });
      const text = await resp.text();
      if (!resp.ok) {
        throw new Error(`Token endpoint error (${resp.status}): ${text}`);
      }
      const data = safeJsonParse(text);
      const key = data?.value ?? data?.client_secret?.value;
      if (!key) throw new Error("No ephemeral key returned from /token");
      return key;
    }

    // ========================
    // MAIN
    // ========================
    async function startSubtitles(){
      try{
        startBtn.disabled = true;
        stopBtn.disabled = false;
        setSubtitle("");

        setStatus("Requesting mic…");
        const EPHEMERAL_KEY = await getEphemeralKey();

        // Mic
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        setStatus("Connecting…");

        // WebRTC
        pc = new RTCPeerConnection();

        // send mic audio to OpenAI
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        // data channel for events
        dc = pc.createDataChannel("oai-events");

        dc.onopen = () => {
          setStatus("Live");

          const instructions =
            "You are a live subtitle translator. The speaker talks in Dutch. " +
            "Output ONLY the translated subtitle in Papiamentu. " +
            "No explanations. Keep it short and readable.";

          // configure session
          dc.send(JSON.stringify({
            type: "session.update",
            session: {
              instructions,
              input_audio_transcription: { model: "gpt-4o-mini-transcribe", language: SOURCE_LANGUAGE },
              modalities: ["text"]
            }
          }));

          // start producing text
          dc.send(JSON.stringify({
            type: "response.create",
            response: {
              modalities: ["text"],
              instructions: "Begin translating now. Output only Papiamentu subtitles."
            }
          }));
        };

        dc.onmessage = (event) => {
          const msg = safeJsonParse(event.data);
          if (!msg) return;

          // Streaming text updates
          if (msg.type === "response.output_text.delta" && typeof msg.delta === "string") {
            setSubtitle((subtitleBar.textContent || "") + msg.delta);
            return;
          }

          // Final text
          if (msg.type === "response.output_text.done") {
            if (typeof msg.text === "string" && msg.text.trim()) setSubtitle(msg.text.trim());
            return;
          }

          // Alternate final shape
          if (msg.type === "response.completed") {
            const text =
              msg?.response?.output?.[0]?.content?.find?.(c => c.type === "output_text")?.text ||
              msg?.response?.output_text ||
              null;
            if (typeof text === "string" && text.trim()) setSubtitle(text.trim());
          }
        };

        dc.onerror = (e) => {
          console.error("DataChannel error:", e);
          setStatus("ERROR: data channel");
        };

        // SDP exchange
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = "https://api.openai.com/v1/realtime";
        const model = "gpt-realtime";

        const sdpResp = await fetch(`${baseUrl}?model=${encodeURIComponent(model)}`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${EPHEMERAL_KEY}`,
            "Content-Type": "application/sdp"
          },
          body: offer.sdp
        });

        const sdpText = await sdpResp.text();
        if (!sdpResp.ok) {
          throw new Error(`Realtime SDP exchange failed (${sdpResp.status}): ${sdpText}`);
        }

        await pc.setRemoteDescription({ type: "answer", sdp: sdpText });
        setStatus("Live");
      } catch (err) {
        console.error(err);
        setStatus("ERROR: " + (err?.message || String(err)));
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    async function stopSubtitles(){
      try{
        setStatus("Stopping…");
        stopBtn.disabled = true;

        if (dc) { try { dc.close(); } catch {} dc = null; }
        if (pc) { try { pc.close(); } catch {} pc = null; }

        if (localStream) {
          localStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
          localStream = null;
        }

        setSubtitle("");
        setStatus("Idle");
      } finally {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    // ========================
    // BUTTONS (guaranteed)
    // ========================
    startBtn.onclick = () => startSubtitles();
    stopBtn.onclick  = () => stopSubtitles();

    // prove script is running
    setStatus("Ready");
  </script>
</body>
</html>
