<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Dutch → Papiamentu Subtitles</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .topbar{
      position:fixed; top:0; left:0; right:0;
      padding:12px 16px; background:#111; color:#fff;
      display:flex; gap:10px; align-items:center; z-index:10000;
    }
    button{ padding:10px 14px; font-size:16px; cursor:pointer; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .status{ margin-left:auto; }
    .page{
      padding-top:64px; min-height:calc(100vh - 64px);
      display:flex; align-items:center; justify-content:center;
      text-align:center; color:#333;
    }
    #subtitleBar{
      position:fixed; left:0; right:0; bottom:0;
      padding:18px 24px; font-size:32px; line-height:1.2;
      background:rgba(0,0,0,.75); color:#fff; text-align:center;
      z-index:9999; min-height:56px; user-select:none;
      white-space:pre-wrap;
    }
    #debugBar{
      position:fixed; left:0; right:0; bottom:86px;
      padding:10px 14px; font-size:14px;
      background:rgba(0,0,0,.55); color:#fff;
      z-index:9998; white-space:pre-wrap;
    }
    body.presentation .topbar { display:none; }
    body.presentation .page { padding-top:0; min-height:100vh; }
    body.presentation #debugBar { display:none; }
  </style>
</head>

<body>
  <div class="topbar">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <span class="status" id="status">Idle</span>
  </div>

  <div class="page">
    <div>
      <h1 style="margin:0 0 8px;">Live Dutch → Papiamentu Subtitles</h1>
      <p style="margin:0; opacity:.8;">
        Click <b>Start</b>. Speak Dutch. Subtitle should appear in <b>Papiamentu</b>.
      </p>
      <p style="margin:12px 0 0; opacity:.7; font-size:14px;">
        Presentation mode: <code>?presentation=true</code>
      </p>
      <p style="margin:12px 0 0; opacity:.7; font-size:14px;">
        Tip: Chrome/Edge work best for Dutch speech recognition.
      </p>
    </div>
  </div>

  <div id="debugBar"></div>
  <div id="subtitleBar"></div>

  <script>
    // ========= Config =========
    const TOKEN_ENDPOINT = "/token";
    const DUTCH_LOCALE = "nl-NL";

    // Hard rule used in BOTH session + per-request prompts:
    const RULES =
      "You are a subtitle translator. Input is DUTCH. " +
      "Output MUST be PAPIAMENTU ONLY. " +
      "Do NOT repeat Dutch. Do NOT explain. " +
      "Return only the translated subtitle text.";

    // Presentation mode
    const params = new URLSearchParams(location.search);
    if (params.get("presentation") === "true") document.body.classList.add("presentation");

    // ========= UI =========
    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const statusEl = document.getElementById("status");
    const subtitleBar = document.getElementById("subtitleBar");
    const debugBar = document.getElementById("debugBar");

    const setStatus = (m) => statusEl.textContent = m;
    const setSubtitle = (t) => subtitleBar.textContent = t || "";
    const setDebug = (t) => debugBar.textContent = t || "";

    const safeJsonParse = (s) => { try { return JSON.parse(s); } catch { return null; } };

    // ========= State =========
    let pc = null;
    let dc = null;
    let recognition = null;
    let lastFinalDutch = "";
    let micStream = null;

    // ========= Token =========
    async function getEphemeralKey(){
      const r = await fetch(TOKEN_ENDPOINT, { cache: "no-store" });
      const t = await r.text();
      if (!r.ok) throw new Error(`Token error ${r.status}: ${t}`);
      const j = safeJsonParse(t);
      const key = j?.value ?? j?.client_secret?.value;
      if (!key) throw new Error("No ephemeral key returned from /token");
      return key;
    }

    // ========= OpenAI Realtime (WebRTC) =========
    async function connectRealtimeWithMic(){
      const EPHEMERAL_KEY = await getEphemeralKey();

      pc = new RTCPeerConnection();

      // Ensure offer has audio (required by OpenAI)
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      micStream.getTracks().forEach(track => pc.addTrack(track, micStream));

      dc = pc.createDataChannel("oai-events");

      dc.onopen = () => {
        setStatus("Live");
        // Set global session rules
        dc.send(JSON.stringify({
          type: "session.update",
          session: {
            instructions: RULES,
            modalities: ["text"]
          }
        }));
      };

      dc.onmessage = (e) => {
        const m = safeJsonParse(e.data);
        if (!m) return;

        // Streaming delta text -> subtitle
        if (m.type === "response.output_text.delta" && typeof m.delta === "string") {
          setSubtitle((subtitleBar.textContent || "") + m.delta);
          return;
        }

        // Final text
        if (m.type === "response.output_text.done" && typeof m.text === "string") {
          const txt = m.text.trim();
          if (txt) setSubtitle(txt);
          return;
        }

        // Alternate final shape
        if (m.type === "response.completed") {
          const t =
            m?.response?.output?.[0]?.content?.find?.(c => c.type === "output_text")?.text ||
            m?.response?.output_text ||
            null;
          if (typeof t === "string" && t.trim()) setSubtitle(t.trim());
        }
      };

      // SDP exchange
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const sdpResp = await fetch("https://api.openai.com/v1/realtime/calls", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${EPHEMERAL_KEY}`,
          "Content-Type": "application/sdp"
        },
        body: offer.sdp
      });

      const sdpText = await sdpResp.text();
      if (!sdpResp.ok) throw new Error(`Realtime failed ${sdpResp.status}: ${sdpText}`);

      await pc.setRemoteDescription({ type: "answer", sdp: sdpText });
    }

    // ========= Send Dutch text to model (FORCE translation) =========
    function sendDutchForTranslation(dutchText){
      if (!dc || dc.readyState !== "open") return;

      // Start clean for each subtitle line
      setSubtitle("");

      // Very explicit user content
      const prompt =
        "Translate the following DUTCH into PAPIAMENTU.\n" +
        "Output ONLY PAPIAMENTU.\n" +
        "Do NOT repeat Dutch.\n\n" +
        "DUTCH:\n" + dutchText;

      dc.send(JSON.stringify({
        type: "conversation.item.create",
        item: {
          type: "message",
          role: "user",
          content: [{ type: "input_text", text: prompt }]
        }
      }));

      // Also enforce rules at response time (belt + suspenders)
      dc.send(JSON.stringify({
        type: "response.create",
        response: {
          modalities: ["text"],
          instructions: RULES
        }
      }));
    }

    // ========= Browser SpeechRecognition (Dutch) =========
    function startSpeechRecognition(){
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) throw new Error("SpeechRecognition not supported. Use Chrome or Edge on desktop.");

      recognition = new SR();
      recognition.lang = DUTCH_LOCALE;
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        let interim = "";
        let finalText = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const txt = res[0]?.transcript || "";
          if (res.isFinal) finalText += txt;
          else interim += txt;
        }

        if (interim.trim()) setDebug("Dutch (listening): " + interim.trim());

        const cleaned = finalText.trim();
        if (cleaned && cleaned !== lastFinalDutch) {
          lastFinalDutch = cleaned;
          setDebug("Dutch (final): " + cleaned);
          sendDutchForTranslation(cleaned);
        }
      };

      recognition.onerror = (e) => {
        console.error(e);
        setStatus("ERROR: speech recognition (" + (e.error || "unknown") + ")");
      };

      recognition.onend = () => {
        // Chrome can stop automatically; restart if still in "running" state
        if (startBtn.disabled) {
          try { recognition.start(); } catch {}
        }
      };

      recognition.start();
    }

    // ========= Start / Stop =========
    async function startAll(){
      try{
        startBtn.disabled = true;
        stopBtn.disabled = false;
        setSubtitle("");
        setDebug("");
        setStatus("Connecting…");

        await connectRealtimeWithMic();
        startSpeechRecognition();

        setStatus("Live");
      } catch (err) {
        console.error(err);
        setStatus("ERROR: " + (err?.message || String(err)));
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    async function stopAll(){
      try{
        setStatus("Stopping…");
        stopBtn.disabled = true;

        if (recognition) {
          try { recognition.onend = null; } catch {}
          try { recognition.stop(); } catch {}
          recognition = null;
        }

        if (dc) { try { dc.close(); } catch {} dc = null; }
        if (pc) { try { pc.close(); } catch {} pc = null; }

        if (micStream) {
          micStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
          micStream = null;
        }

        setSubtitle("");
        setDebug("");
        setStatus("Idle");
      } finally {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    startBtn.onclick = startAll;
    stopBtn.onclick = stopAll;
    setStatus("Ready");
  </script>
</body>
</html>
