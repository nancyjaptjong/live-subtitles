<script>
  // ===== Config =====
  const TOKEN_ENDPOINT = "/token"; // Cloudflare function at /functions/token.js => /token
  const SOURCE_LANGUAGE = "nl";     // Dutch input
  const TARGET_LANGUAGE = "pap";    // Papiamentu output (best effort)

  // ===== UI =====
  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");
  const statusEl = document.getElementById("status");

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg;
  }

  // ===== State =====
  let pc = null;
  let dc = null;
  let localStream = null;

  // Try to find a subtitle element if you already have one
  // (If you don't, the script will create a bottom subtitle bar automatically)
  let subtitleEl =
    document.getElementById("subtitle") ||
    document.getElementById("subtitles") ||
    document.getElementById("caption") ||
    document.getElementById("captions") ||
    null;

  function ensureSubtitleBar() {
    if (subtitleEl) return subtitleEl;

    subtitleEl = document.createElement("div");
    subtitleEl.id = "subtitle";
    subtitleEl.style.position = "fixed";
    subtitleEl.style.left = "0";
    subtitleEl.style.right = "0";
    subtitleEl.style.bottom = "0";
    subtitleEl.style.padding = "18px 24px";
    subtitleEl.style.fontSize = "32px";
    subtitleEl.style.lineHeight = "1.2";
    subtitleEl.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    subtitleEl.style.background = "rgba(0,0,0,0.75)";
    subtitleEl.style.color = "white";
    subtitleEl.style.textAlign = "center";
    subtitleEl.style.zIndex = "9999";
    subtitleEl.style.userSelect = "none";
    subtitleEl.textContent = "";

    document.body.appendChild(subtitleEl);
    return subtitleEl;
  }

  function setSubtitle(text) {
    const el = ensureSubtitleBar();
    el.textContent = text || "";
  }

  // ===== Helpers =====
  async function getEphemeralKey() {
    const resp = await fetch(TOKEN_ENDPOINT, { cache: "no-store" });
    if (!resp.ok) {
      const t = await resp.text();
      throw new Error(`Token endpoint error (${resp.status}): ${t}`);
    }
    const data = await resp.json();
    const key = data.value ?? data.client_secret?.value;
    if (!key) throw new Error("No ephemeral key returned from /token");
    return key;
  }

  function safeJsonParse(s) {
    try { return JSON.parse(s); } catch { return null; }
  }

  // ===== Realtime WebRTC Connect =====
  async function start() {
    try {
      setStatus("Requesting mic…");
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // 1) Get ephemeral key
      const EPHEMERAL_KEY = await getEphemeralKey();

      // 2) Capture microphone
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      setStatus("Connecting…");

      // 3) WebRTC Peer Connection
      pc = new RTCPeerConnection();

      // Send mic audio to OpenAI
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      // Receive remote audio if the model sends any (optional)
      pc.ontrack = (event) => {
        // If you want to play model audio, uncomment:
        // const audio = document.createElement("audio");
        // audio.autoplay = true;
        // audio.srcObject = event.streams[0];
        // document.body.appendChild(audio);
      };

      // 4) Data channel for events (text, transcripts, etc.)
      dc = pc.createDataChannel("oai-events");

      dc.onopen = () => {
        setStatus("Live");
        // Configure the session: ask for subtitles in Papiamentu from Dutch speech
        // We instruct the model to act like a real-time subtitle translator.
        const instructions =
          `You are a live subtitle translator. The speaker talks in Dutch. ` +
          `Output ONLY the translated subtitle in Papiamentu. ` +
          `No explanations. Keep it short, natural, and readable.`;

        dc.send(JSON.stringify({
          type: "session.update",
          session: {
            // These names can vary by Realtime version; harmless if ignored.
            instructions,
            input_audio_transcription: { model: "gpt-4o-mini-transcribe", language: SOURCE_LANGUAGE },
            // We'll request text outputs for subtitles
            modalities: ["text"]
          }
        }));

        // Kick off continuous transcription/translation behavior.
        // Some Realtime builds respond better when you explicitly request.
        dc.send(JSON.stringify({
          type: "response.create",
          response: {
            modalities: ["text"],
            instructions:
              `Start now. As you receive Dutch speech, stream the Papiamentu subtitle.` +
              ` Output only subtitle text.`,
          }
        }));
      };

      dc.onmessage = (event) => {
        // Realtime sends JSON event objects
        const msg = safeJsonParse(event.data);
        if (!msg) return;

        // You'll see lots of different event types; we only care about text deltas/final
        // Common patterns include: response.output_text.delta / response.output_text.done
        // We'll handle multiple possible shapes safely.

        // 1) Output text delta
        if (msg.type === "response.output_text.delta" && typeof msg.delta === "string") {
          // Append streaming subtitle
          setSubtitle((ensureSubtitleBar().textContent || "") + msg.delta);
          return;
        }

        // 2) Output text done (final)
        if (msg.type === "response.output_text.done") {
          // Some builds send final text in msg.text
          if (typeof msg.text === "string" && msg.text.trim()) {
            setSubtitle(msg.text.trim());
          }
          return;
        }

        // 3) Some builds send content blocks in response.completed
        if (msg.type === "response.completed") {
          const text =
            msg?.response?.output?.[0]?.content?.find?.(c => c.type === "output_text")?.text ||
            msg?.response?.output_text ||
            null;
          if (typeof text === "string" && text.trim()) {
            setSubtitle(text.trim());
          }
          return;
        }

        // 4) If you want to see what events are coming in:
        // console.log("Realtime event:", msg);
      };

      dc.onerror = (e) => {
        console.error("DataChannel error:", e);
        setStatus("Error (data channel)");
      };

      // 5) Create offer and send to OpenAI Realtime
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const baseUrl = "https://api.openai.com/v1/realtime";
      const model = "gpt-realtime"; // server-side model choice (matches /token)
      const sdpResp = await fetch(`${baseUrl}?model=${encodeURIComponent(model)}`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${EPHEMERAL_KEY}`,
          "Content-Type": "application/sdp"
        },
        body: offer.sdp
      });

      if (!sdpResp.ok) {
        const t = await sdpResp.text();
        throw new Error(`Realtime SDP exchange failed (${sdpResp.status}): ${t}`);
      }

      const answerSdp = await sdpResp.text();
      await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

      setStatus("Live");
    } catch (err) {
      console.error(err);
      setStatus("Error (check console)");
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }
  }

  async function stop() {
    try {
      setStatus("Stopping…");
      stopBtn.disabled = true;

      if (dc) {
        try { dc.close(); } catch {}
        dc = null;
      }

      if (pc) {
        try { pc.close(); } catch {}
        pc = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(t => {
          try { t.stop(); } catch {}
        });
        localStream = null;
      }

      setSubtitle("");
      setStatus("Idle");
    } finally {
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }
  }

  // Wire buttons
  startBtn.addEventListener("click", start);
  stopBtn.addEventListener("click", stop);

  // Initial UI state
  setStatus("Idle");
  stopBtn.disabled = true;
</script>
